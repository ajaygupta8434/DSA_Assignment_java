Assignment DSA (submit before 28.02.2026)

•	Array and Array operations 

•	Stack and Its Operations

•	Queue and Its Operations

•	Linked List and Its Operations

•	Linear Search Algorithm

•	Binary Search Algorithm

Array and Array operations related Assignment:
1.	Find the Missing Number: Given an array of numbers containing elements from 1 to n, find the missing number.
2.	Reverse an Array: Reverse the order of elements in an array in place.
3.	Move Zeroes: Move all zeros to the end of an array while maintaining the relative order of the non-zero elements.
4.	Remove Duplicates from Sorted Array: Modify a sorted array so that each element appears only once.
5.	Second Largest Element: Find the second largest element without sorting the array.
6.	Max Consecutive Ones: Given a binary array, find the maximum number of consecutive 1s.
7.	Check if Sorted Array: Determine if an array is sorted in ascending or descending order.

8.	Two Sum: Given an array and a target sum, find two numbers that add up to the target.
9.	Merge Sorted Arrays: Merge two sorted arrays into a single sorted array.
10.	Rotate an Array: Rotate the array to the right by steps.
11.	Maximum Subarray Sum: Find the contiguous subarray with the largest sum (Kadane's algorithm).
12.	Subarray Sum Equals K: Find the number of subarrays whose sum is equal to a target value 
13.	Find Duplicate in an Array: Find the duplicate element in an array containing elements within a specific range.
14.	Merge Intervals: Given a collection of intervals, merge all overlapping intervals.

Stack and Stack Operations Related Assignment:
1.	Parenthesis Checker (Balanced Brackets): Determine if an expression has balanced opening and closing brackets. This is a classic application where opening brackets are pushed onto the stack and closing brackets must match the top of the stack when popped.
2.	Reverse a String/Stack: Use a stack to reverse a string or the elements within the stack itself, demonstrating the LIFO property.
3.	Implement Stack/Queue using the other: Building one data structure using the operations of the other (e.g., implementing a queue using two stacks or a stack using queues).
4.	Delete Middle Element: Deleting the middle element from a stack without using another explicit data structure.

5.	Evaluate Postfix/Prefix Expression: Calculate the value of an expression in postfix or prefix notation using a stack.
6.	Infix to Postfix/Prefix Conversion: Convert one form of an expression to another, applying precedence rules and associativity.
7.	Next Greater/Smaller Element: For each element in an array, find the nearest element to its right (or left) that is greater or smaller. This is a key monotonic stack problem pattern.

Queue and Queue Related Assignment:
1.	Implement Queue using Stacks: Design a queue data structure using only stacks to store the elements.
2.	Reverse a Queue: Reverse the order of elements in a given queue, often using an auxiliary stack or recursion.
3.	Reverse First K Elements of a Queue: Reverse only the first k elements of the queue, leaving the rest in the same relative order.
4.	Circular Queue Implementation: Implement a queue that efficiently reuses array space by connecting the last position back to the first, avoiding the shifting cost of a simple array implementation.

5.	Sliding Window Maximum: Find the maximum element in every contiguous subarray (window) of a given size k.
6.	First Negative Integer in Every Window of Size K: Find the first negative integer in each window of a given size in an array.
7.	Generate Binary Numbers: Generate binary numbers from 1 to n using a queue to manage the sequence of numbers to process.
8.	First Non-Repeating Character in a Stream: Find the first non-repeating character in a stream of characters as they are added, commonly solved using a queue and a frequency map.


Linked List Related Assignment:
1.	Reverse a Linked List: The classic problem of reversing the direction of the links, typically in-place using iterative or recursive approaches.
2.	Find the Middle Element: Efficiently finding the middle node, often solved using the slow and fast pointer (tortoise and hare) technique to achieve this in a single pass.
3.	Nth Node from the End: Finding the Nth node from the end of the list, often using two pointers separated by N nodes.
4.	Remove Duplicates from a Sorted Linked List: Iterating through a sorted list and removing nodes with the same value as their predecessor.
5.	Merge Two Sorted Linked Lists: Combining two lists that are already sorted into a single new sorted list efficiently.
6.	Detect a Loop (Cycle): Determining if a linked list contains a cycle, also commonly solved with the slow and fast pointer method.

7.	Remove Nth Node From End of List: Deleting a specific node based on its position from the end of the list.
8.	Add Two Numbers: Summing two numbers that are represented by linked lists, where each node contains a single digit and the digits are stored in reverse order.
9.	Check if a Linked List is a Palindrome: Determining if the sequence of data in the list is the same forwards and backwards.
10.	Intersection Point of Two Linked Lists: Finding the specific node where two separate linked lists begin to intersect and share a common tail.
11.	Swap Nodes in Pairs: Swapping adjacent nodes in the list without changing the data values, only the pointers.
12.	Partition List: Given a value x, rearranging the list so all nodes less than x come before all nodes greater than or equal to x.

Linear Search Related Assignment:
1.	Basic Search: Find the index of a given element X in an array/list. If it's not present, return -1.
2.	Search in a Range: Find a target element within a specific range of indices within an array.
3.	Search in String: Apply the linear search logic to find a specific character within a string.
4.	Find the Minimum/Maximum Number: Traverse the entire array to find the smallest or largest element as well as second largest and second smallest.
5.	Search in 2D Arrays: Extend the linear search concept to a two-dimensional array, checking each cell sequentially.
6.	Counting Occurrences: Determine how many times a particular element appears in an array.
7.	Find the Missing Number: Given an array of size with distinct integers in the range of [1, n], find the missing number. A naive approach involves linearly searching for each number in the range within the array.
8.	Find the First Repeating Element: Identify the element that occurs more than once and whose first occurrence has the smallest index.

Binary Search Related Assignment:
1.	Searching in a Sorted Array: The standard application, involving finding a target element or its insertion position.
2.	First and Last Occurrence: Finding the first and last index of a target element that may have duplicates in a sorted array.
3.	Count Occurrences: Using the first and last occurrence indices to determine the total count of a specific element.
4.	Finding Floor and Ceiling: Locating the largest element less than or equal to a target (floor) and the smallest element greater than or equal to a target (ceiling) in a sorted array.
5.	Square Root of a Number: Calculating the integer square root of a number efficiently by searching for the value x where x*x <= number and (x+1)*(x+1) > number.


